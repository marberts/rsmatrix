[{"path":"https://marberts.github.io/rsmatrix/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Steve Martin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://marberts.github.io/rsmatrix/articles/rsmatrix.html","id":"some-data","dir":"Articles","previous_headings":"","what":"Some data","title":"Making repeat-sales indexes","text":"Let’s start fictitious data house sales five cities ten-year period. data won’t make interesting price index, ’re broadly representative type data used make housing price index practice.","code":"set.seed(15243)  periods <- seq(as.Date(\"2010-01-01\"), as.Date(\"2019-12-31\"), \"day\")  prices <- data.frame(   sale = sample(periods, 5e5, TRUE),   property = factor(sprintf(\"%05d\", sample(1:5e4, 5e5, TRUE))),   city = factor(sample(1:5, 1e5, TRUE)),   price = round(rlnorm(5e5) * 5e5, -3) )  prices <- prices[order(prices$city, prices$property, prices$sale), ] row.names(prices) <- NULL  head(prices) #>         sale property city   price #> 1 2012-11-18    00001    1 2831000 #> 2 2018-10-05    00001    1  290000 #> 3 2010-09-20    00002    1 1519000 #> 4 2019-12-19    00002    1  269000 #> 5 2012-06-25    00003    1  712000 #> 6 2016-10-15    00003    1  520000"},{"path":"https://marberts.github.io/rsmatrix/articles/rsmatrix.html","id":"preparing-to-make-the-matrices","dir":"Articles","previous_headings":"","what":"Preparing to make the matrices","title":"Making repeat-sales indexes","text":"repeat-sales method uses multiple sales property time identify change housing prices. major step prepare data method make pairs consecutive sales (sales pairs). Note remove sizable chunk properties one sale. ’ll making monthly index, ’s useful turn sale dates year months constructing sales pairs. (Using, say, yearmon class zoo instead factor means can done making sales pairs.) rs_pairs() function gives position previous sale property city data. Now data oriented sales pairs, can remove pairs transactions don’t belong calculation. goal help motivate assumption time-invariant differences quality confound change housing prices change composition housing sells time. ’s normal remove pairs transactions close together (e.g., less two months apart), properties may flips result financial difficulty indicative property otherwise sold . Note filters properties sell . Properties large change price may undergone major improvements depreciation similarly undermine assumptions repeat-sales method. many ways try filter transactions, simple approach remove pairs sales monthly return property greater , say, 2.5 median absolute deviations median. (gpindex package several methods dealing extreme changes prices.)","code":"interaction(prices$city, prices$property, drop = TRUE) |>   tabulate() |>   quantile() #>   0%  25%  50%  75% 100%  #>    1    1    2    3   11 prices$period <- cut(prices$sale, \"month\") sales_pairs <- rs_pairs(prices$sale, interaction(prices$city, prices$property)) prices[c(\"price_prev\", \"period_prev\")] <- prices[sales_pairs, c(\"price\", \"period\")]  head(prices) #>         sale property city   price     period price_prev period_prev #> 1 2012-11-18    00001    1 2831000 2012-11-01    2831000  2012-11-01 #> 2 2018-10-05    00001    1  290000 2018-10-01    2831000  2012-11-01 #> 3 2010-09-20    00002    1 1519000 2010-09-01    1519000  2010-09-01 #> 4 2019-12-19    00002    1  269000 2019-12-01    1519000  2010-09-01 #> 5 2012-06-25    00003    1  712000 2012-06-01     712000  2012-06-01 #> 6 2016-10-15    00003    1  520000 2016-10-01     712000  2012-06-01 prices$holding_period <- with(prices, as.numeric(period) - as.numeric(period_prev))  prices <- subset(prices, holding_period > 2) library(gpindex) monthly_return <- with(prices, (price / price_prev)^(1 / holding_period))  robust_z <- grouped(robust_z) prices <- subset(prices, !robust_z(monthly_return, group = city))  head(prices) #>          sale property city  price     period price_prev period_prev #> 2  2018-10-05    00001    1 290000 2018-10-01    2831000  2012-11-01 #> 4  2019-12-19    00002    1 269000 2019-12-01    1519000  2010-09-01 #> 6  2016-10-15    00003    1 520000 2016-10-01     712000  2012-06-01 #> 8  2011-07-18    00004    1 305000 2011-07-01      90000  2010-07-01 #> 9  2013-12-03    00004    1 768000 2013-12-01     305000  2011-07-01 #> 10 2018-08-02    00004    1 121000 2018-08-01     768000  2013-12-01 #>    holding_period #> 2              71 #> 4             111 #> 6              52 #> 8              12 #> 9              29 #> 10             56"},{"path":"https://marberts.github.io/rsmatrix/articles/rsmatrix.html","id":"calculating-a-repeat-sales-index","dir":"Articles","previous_headings":"","what":"Calculating a repeat-sales index","title":"Making repeat-sales indexes","text":"data right form, potentially problematic transactions gone, can now make repeat-sales matrices calculate housing price index. strategy make constructor function based sales-pair data can used make repeat-sales matrices. matrices naturally sparse, large volume transactions means ’ll benefit using sparse matrices. simplest repeat-sales index geometric repeat sales (GRS) index.1 index uses \\(Z\\) \\(y\\) matrices. various inverse-variance (interval) weighting schemes found literature. weights result regressing residuals GRS model function holding period. well-known weights, Case-Shiller weights, model variance linear function holding period. Adding square holding period model variance, without intercept, common variation interval weights. weights can extended account house selling twice. Another type repeat-sales index arithmetic repeat sales (ARS) index. index uses \\(Z\\), \\(X\\), \\(Y\\) matrices. Like GRS index, ARS index can calculated inverse-variance weights. Dividing \\(X\\) \\(Y\\) matrices price first sale row produces equally-weighted arithmetic index (opposed value-weighted index). index calculated, ’s often easier turn matrix-like object cities rows time periods columns. easiest way piar package.","code":"matrices <- with(   prices,   rs_matrix(period, period_prev, price, price_prev, city, sparse = TRUE) ) Z <- matrices(\"Z\") y <- matrices(\"y\")  grs <- exp(solve(crossprod(Z), crossprod(Z, y))) head(grs) #> 6 x 1 Matrix of class \"dgeMatrix\" #>                   [,1] #> 1.2010-02-01 0.9319471 #> 2.2010-02-01 1.0682105 #> 3.2010-02-01 1.0434833 #> 4.2010-02-01 1.0185787 #> 5.2010-02-01 0.9715417 #> 1.2010-03-01 1.0499673 grs_resid <- y - Z %*% log(grs)  mdl <- lm(as.numeric(grs_resid)^2 ~ prices$holding_period) W <- Diagonal(x = 1 / fitted.values(mdl))  grs_cs <- exp(solve(crossprod(Z, W %*% Z), crossprod(Z, W %*% y))) head(grs_cs) #> 6 x 1 Matrix of class \"dgeMatrix\" #>                   [,1] #> 1.2010-02-01 0.9216778 #> 2.2010-02-01 1.0395309 #> 3.2010-02-01 1.0265610 #> 4.2010-02-01 0.9885539 #> 5.2010-02-01 0.9611430 #> 1.2010-03-01 1.0373087 X <- matrices(\"X\") Y <- matrices(\"Y\")  ars <- 1 / solve(crossprod(Z, X), crossprod(Z, Y)) head(ars) #> 6 x 1 Matrix of class \"dgeMatrix\" #>                   [,1] #> 1.2010-02-01 0.9049071 #> 2.2010-02-01 1.1567195 #> 3.2010-02-01 1.0093530 #> 4.2010-02-01 1.0107540 #> 5.2010-02-01 0.9458214 #> 1.2010-03-01 0.9840927 ars_resid <- Y - X %*% (1 / ars)  mdl <- lm(as.numeric(ars_resid)^2 ~ prices$holding_period) W <- Diagonal(x = 1 / fitted.values(mdl))  ars_cs <- 1 / solve(crossprod(Z, W %*% X), crossprod(Z, W %*% Y)) head(ars_cs) #> 6 x 1 Matrix of class \"dgeMatrix\" #>                   [,1] #> 1.2010-02-01 0.9040179 #> 2.2010-02-01 1.1194659 #> 3.2010-02-01 0.9667189 #> 4.2010-02-01 0.9549480 #> 5.2010-02-01 0.9161033 #> 1.2010-03-01 0.9856805 ars_ew <- with(   prices,   1 / solve(crossprod(Z, X / price_prev), crossprod(Z, Y / price_prev)) )  head(ars_ew) #> 6 x 1 Matrix of class \"dgeMatrix\" #>                   [,1] #> 1.2010-02-01 0.9831875 #> 2.2010-02-01 1.1454796 #> 3.2010-02-01 1.1332362 #> 4.2010-02-01 0.9957358 #> 5.2010-02-01 0.8859613 #> 1.2010-03-01 0.9510087 library(piar)  dimensions <- do.call(rbind, strsplit(rownames(grs), \".\", fixed = TRUE)) grs_piar <- elemental_index(   grs,   period = dimensions[, 2],   ea = dimensions[, 1],   chainable = FALSE )  head(grs_piar, c(5, 5)) #> Fixed-base price index for 5 levels over 5 time periods  #>   2010-02-01 2010-03-01 2010-04-01 2010-05-01 2010-06-01 #> 1  0.9319471   1.049967  1.0312130  0.9332345  1.0074811 #> 2  1.0682105   0.984812  1.0840525  1.0113186  0.9645851 #> 3  1.0434833   1.044671  0.9526141  0.9330665  1.0234300 #> 4  1.0185787   1.048738  1.0757727  1.1258297  1.0099260 #> 5  0.9715417   1.025133  1.0648382  1.0387825  1.0930171"},{"path":"https://marberts.github.io/rsmatrix/articles/rsmatrix.html","id":"sales-pair-contributions","dir":"Articles","previous_headings":"","what":"Sales pair contributions","title":"Making repeat-sales indexes","text":"Repeat-sales indexes simple interpretation type efficient back-price imputation. ’s best include base period index prior imputation. GRS index point time simply geometric mean imputed price relatives. makes easy calculate percent-change contribution property point time. applies ARS index, noting weighted arithmetic mean imputed price relatives.","code":"grs <- c(setNames(rep(1, 5), paste(1:5, \"2010-01-01\", sep = \".\")), grs[, 1]) ars <- c(setNames(rep(1, 5), paste(1:5, \"2010-01-01\", sep = \".\")), ars[, 1]) grs_contributions <- Map(   \\(df, df_prev) {     impute_back <- with(df, price_prev / grs[paste(city, period_prev, sep = \".\")])     names(impute_back) <- row.names(df)     impute_forward <- with(df_prev, price / grs[paste(city, period, sep = \".\")])     names(impute_forward) <- row.names(df_prev)     geometric_contributions(       c(df$price / impute_back, df_prev$price_prev / impute_forward)     )   },   split(prices, interaction(prices$city, prices$period)),   split(prices, interaction(prices$city, prices$period_prev)) )  all.equal(sapply(grs_contributions, sum) + 1, grs) #> [1] TRUE  range(unlist(grs_contributions)) #> [1] -0.008215347  0.009111019 ars_contributions <- Map(   \\(df, df_prev) {     impute_back <- with(df, price_prev / ars[paste(city, period_prev, sep = \".\")])     names(impute_back) <- row.names(df)     impute_forward <- with(df_prev, price / ars[paste(city, period, sep = \".\")])     names(impute_forward) <- row.names(df_prev)     arithmetic_contributions(       c(df$price / impute_back, df_prev$price_prev / impute_forward),       c(impute_back, impute_forward)     )   },   split(prices, interaction(prices$city, prices$period)),   split(prices, interaction(prices$city, prices$period_prev)) )  all.equal(sapply(ars_contributions, sum) + 1, ars) #> [1] TRUE  range(unlist(ars_contributions)) #> [1] -0.07041332  0.08316015"},{"path":"https://marberts.github.io/rsmatrix/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Steve Martin. Author, maintainer, copyright holder.","code":""},{"path":"https://marberts.github.io/rsmatrix/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin S (2024). rsmatrix: Matrices Repeat-Sales Price Indexes. doi:10.5281/zenodo.10110159, R package version 0.2.9, https://cran.r-project.org/package=rsmatrix.","code":"@Manual{,   title = {{rsmatrix}: Matrices for Repeat-Sales Price Indexes},   author = {Steve Martin},   year = {2024},   doi = {10.5281/zenodo.10110159},   url = {https://cran.r-project.org/package=rsmatrix},   note = {R package version 0.2.9}, }"},{"path":"https://marberts.github.io/rsmatrix/index.html","id":"matrices-for-repeat-sales-price-indexes-","dir":"","previous_headings":"","what":"Matrices for Repeat-Sales Price Indexes","title":"Matrices for Repeat-Sales Price Indexes","text":"Calculate matrices Shiller (1991) serve foundation many repeat-sales price indexes.","code":""},{"path":"https://marberts.github.io/rsmatrix/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Matrices for Repeat-Sales Price Indexes","text":"Get stable release CRAN. Install development version R-Universe directly GitHub.","code":"install.package(\"rsmatrix\") install.packages(\"rsmatrix\", repos = c(\"https://marberts.r-universe.dev\", \"https://cloud.r-project.org\")) pak::pak(\"marberts/rsmatrix\")"},{"path":"https://marberts.github.io/rsmatrix/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Matrices for Repeat-Sales Price Indexes","text":"repeat-sales price indexes used practice based matrices Shiller (1991, sections -II), e.g., S&P’s Case-Shiller index, Teranet-National Bank’s HPI, formerly Statistics Canada’s RPPI. Let’s consider simplest non-trivial example see make use matrices. cases data need first structured sales pairs, can done rs_pairs() function. rs_matrix() function can now used produce function constructs matrices. Standard repeat-sales indexes just simple matrix operations using matrices.","code":"library(rsmatrix)  # Make some data for two products selling over three periods sales <- data.frame(   id = c(1, 1, 1, 2, 2),   date = c(1, 2, 3, 1, 3),   price = c(1, 3, 2, 1, 1) )  sales ##   id date price ## 1  1    1     1 ## 2  1    2     3 ## 3  1    3     2 ## 4  2    1     1 ## 5  2    3     1 # Turn into sales pairs sales[c(\"date_prev\", \"price_prev\")] <- sales[rs_pairs(sales$date, sales$id), c(\"date\", \"price\")]  (sales <- subset(sales, date > date_prev)) ##   id date price date_prev price_prev ## 2  1    2     3         1          1 ## 3  1    3     2         2          3 ## 5  2    3     1         1          1 # Calculate matrices matrix_constructor <- with(sales, rs_matrix(date, date_prev, price, price_prev)) matrices <- sapply(c(\"Z\", \"X\", \"y\", \"Y\"), matrix_constructor)  matrices$Z ##    2 3 ## 1  1 0 ## 2 -1 1 ## 3  0 1 matrices$X ##    2 3 ## 1  3 0 ## 2 -3 2 ## 3  0 1 # Calculate the GRS index in Bailey, Muth, and Nourse (1963) b <- with(matrices, solve(crossprod(Z), crossprod(Z, y))[, 1]) (grs <- exp(b) * 100) ##        2        3  ## 238.1102 125.9921 # Calculate the ARS index in Shiller (1991) b <- with(matrices, solve(crossprod(Z, X), crossprod(Z, Y))[, 1]) (ars <- 100 / b) ##        2        3  ## 240.0000 133.3333"},{"path":"https://marberts.github.io/rsmatrix/index.html","id":"prior-work","dir":"","previous_headings":"","what":"Prior work","title":"Matrices for Repeat-Sales Price Indexes","text":"hpiR package functionality making repeat-sales indexes, McSpatial package (formerly CRAN). Although easier use, packages lack flexibility compute number indexes found literature (e.g., arithmetic repeat-sales indexes). functions package build rsi package Kirby-McGregor Martin (2019), also gives good background theory repeat-sales indexes.","code":""},{"path":"https://marberts.github.io/rsmatrix/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Matrices for Repeat-Sales Price Indexes","text":"ILO, IMF, OECD, UN, World Bank, Eurostat. (2013). Handbook Residential Property Prices Indices (RPPIs). Eurostat. Kirby-McGregor, M., Martin, S. (2019). R package calculating repeat-sale price indices. Romanian Statistical Review, 3:17-33. Shiller, R. J. (1991). Arithmetic repeat sales price estimators. Journal Housing Economics, 1(1):110-126.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Shiller's repeat-sales matrices — rs_matrix","title":"Shiller's repeat-sales matrices — rs_matrix","text":"Create function compute \\(Z\\), \\(X\\), \\(y\\), \\(Y\\) matrices Shiller (1991, sections -II) sales-pair data order calculate repeat-sales price index.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shiller's repeat-sales matrices — rs_matrix","text":"","code":"rs_matrix(t2, t1, p2, p1, f = NULL, sparse = FALSE)"},{"path":"https://marberts.github.io/rsmatrix/reference/rs_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shiller's repeat-sales matrices — rs_matrix","text":"t2, t1 pair vectors giving time period second first sale, respectively. Usually vector dates, values possible can coerced character vectors sorted chronological order (.e., order()). p2, p1 pair numeric vectors giving price second first sale, respectively. f optional factor length t1 t2, vector turned factor, used group sales. sparse sparse matrices Matrix package used (faster large datasets), regular dense matrices (default)?","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shiller's repeat-sales matrices — rs_matrix","text":"function takes single argument naming desired matrix. returns one two matrices (\\(Z\\) \\(X\\)) two vectors (\\(y\\) \\(Y\\)), either regular matrices sparse = FALSE, sparse matrices class dgCMatrix sparse = TRUE.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shiller's repeat-sales matrices — rs_matrix","text":"function returned rs_matrix() computes generalization matrices Shiller (1991, sections -II) applicable grouped data. useful calculating separate indexes many, say, cities without needing explicit loop. \\(Z\\), \\(X\\), \\(Y\\) matrices well defined either t1 t2 missing values, error thrown case. Similarly, always case t2 > t1, otherwise warning given.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Shiller's repeat-sales matrices — rs_matrix","text":"Bailey, M. J., Muth, R. F., Nourse, H. O. (1963). regression method real estate price index construction. Journal American Statistical Association, 53(304):933-942. Shiller, R. J. (1991). Arithmetic repeat sales price estimators. Journal Housing Economics, 1(1):110-126.","code":""},{"path":[]},{"path":"https://marberts.github.io/rsmatrix/reference/rs_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shiller's repeat-sales matrices — rs_matrix","text":"","code":"# Make some data x <- data.frame(   date = c(3, 2, 3, 2, 3, 3),   date_prev = c(1, 1, 2, 1, 2, 1),   price = 6:1,   price_prev = 1 )  # Calculate matrices mat <- with(x, rs_matrix(date, date_prev, price, price_prev)) Z <- mat(\"Z\") # Z matrix X <- mat(\"X\") # X matrix y <- mat(\"y\") # y vector Y <- mat(\"Y\") # Y vector  # Calculate the GRS index in Bailey, Muth, and Nourse (1963) b <- solve(crossprod(Z), crossprod(Z, y))[, 1] # or b <- qr.coef(qr(Z), y) (grs <- exp(b) * 100) #>        2        3  #> 235.0755 403.5654   # Standard errors vcov <- rs_var(y - Z %*% b, Z) sqrt(diag(vcov)) * grs # delta method #>        2        3  #> 111.0797 257.6581   # Calculate the ARS index in Shiller (1991) b <- solve(crossprod(Z, X), crossprod(Z, Y))[, 1] # or b <- qr.coef(qr(crossprod(Z, X)), crossprod(Z, Y)) (ars <- 100 / b) #>        2        3  #> 310.5263 491.6667   # Standard errors vcov <- rs_var(Y - X %*% b, Z, X) sqrt(diag(vcov)) * ars^2 / 100 # delta method #>        2        3  #> 100.0316 232.3111   # Works with grouped data x <- data.frame(   date = c(3, 2, 3, 2),   date_prev = c(2, 1, 2, 1),   price = 4:1,   price_prev = 1,   group = c(\"a\", \"a\", \"b\", \"b\") )  mat <- with(x, rs_matrix(date, date_prev, price, price_prev, group)) b <- solve(crossprod(mat(\"Z\"), mat(\"X\")), crossprod(mat(\"Z\"), mat(\"Y\")))[, 1] 100 / b #>  a.2  b.2  a.3  b.3  #>  300  100 1200  200"},{"path":"https://marberts.github.io/rsmatrix/reference/rs_pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Sales pairs — rs_pairs","title":"Sales pairs — rs_pairs","text":"Turn repeat-sales data sales pairs suitable making repeat-sales matrices.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sales pairs — rs_pairs","text":"","code":"rs_pairs(period, product, match_first = TRUE)"},{"path":"https://marberts.github.io/rsmatrix/reference/rs_pairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sales pairs — rs_pairs","text":"period vector gives time period sale. Usually date vector, factor levels chronological order, values possible can sorted chronological order (.e., order()). product vector gives product identifier sale. Usually factor vector integer codes product. match_first products first period match (default)?","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sales pairs — rs_pairs","text":"numeric vector indices giving position previous sale product, convention previous sale first sale match_first = TRUE, NA otherwise. Ties resolved according order appear period.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_pairs.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sales pairs — rs_pairs","text":"order() workhorse rs_pairs(), performance can sensitive types period product, can slow large character vectors.","code":""},{"path":[]},{"path":"https://marberts.github.io/rsmatrix/reference/rs_pairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sales pairs — rs_pairs","text":"","code":"# Make sales pairs x <- data.frame(   id = c(1, 1, 1, 3, 2, 2, 3, 3),   date = c(1, 2, 3, 2, 1, 3, 4, 1),   price = c(1, 3, 2, 3, 1, 1, 1, 2) )  pairs <- rs_pairs(x$date, x$id)  x[c(\"date_prev\", \"price_prev\")] <- x[c(\"date\", \"price\")][pairs, ]  x #>   id date price date_prev price_prev #> 1  1    1     1         1          1 #> 2  1    2     3         1          1 #> 3  1    3     2         2          3 #> 4  3    2     3         1          2 #> 5  2    1     1         1          1 #> 6  2    3     1         1          1 #> 7  3    4     1         2          3 #> 8  3    1     2         1          2"},{"path":"https://marberts.github.io/rsmatrix/reference/rs_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Robust variance matrix for repeat-sales indexes — rs_var","title":"Robust variance matrix for repeat-sales indexes — rs_var","text":"Convenience function compute cluster-robust variance matrix linear regression, without instruments, clustering occurs along one dimension. Useful calculating variance matrix regression calculated manually.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robust variance matrix for repeat-sales indexes — rs_var","text":"","code":"rs_var(u, Z, X = Z, ids = seq_len(nrow(X)), df = NULL)"},{"path":"https://marberts.github.io/rsmatrix/reference/rs_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robust variance matrix for repeat-sales indexes — rs_var","text":"u \\(n \\times 1\\) vector residuals linear regression. Z \\(n \\times k\\) matrix instruments. X \\(n \\times k\\) matrix covariates. ids factor length \\(n\\), something can coerced one, groups observations u. default observation belongs group. df optional degrees freedom correction. Default Stata's small sample degrees freedom correction.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Robust variance matrix for repeat-sales indexes — rs_var","text":"\\(k \\times k\\) covariance matrix.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_var.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Robust variance matrix for repeat-sales indexes — rs_var","text":"function calculates standard robust variance matrix linear regression, Manski (1988, section 8.1.2) White (2001, Theorem 6.3); , \\((Z'X)^{-1} V (X'Z)^{-1}\\). useful regression calculated hand. generalizes variance matrix proposed Shiller (1991, section II) property sells twice. function gives result vcovHC(x, type = 'sss', cluster = 'group') plm package.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_var.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Robust variance matrix for repeat-sales indexes — rs_var","text":"Manski, C. (1988). Analog Estimation Methods Econometrics. Chapman Hall. Shiller, R. J. (1991). Arithmetic repeat sales price estimators. Journal Housing Economics, 1(1):110-126. White, H. (2001). Asymptotic Theory Econometricians (revised edition). Emerald Publishing.","code":""},{"path":"https://marberts.github.io/rsmatrix/reference/rs_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Robust variance matrix for repeat-sales indexes — rs_var","text":"","code":"# Makes some groups in mtcars mtcars$clust <- letters[1:4]  # Matrices for regression x <- model.matrix(~ cyl + disp, mtcars) y <- matrix(mtcars$mpg)  # Regression coefficients b <- solve(crossprod(x), crossprod(x, y))  # Residuals r <- y - x %*% b  # Robust variance matrix vcov <- rs_var(r, x, ids = mtcars$clust)  if (FALSE) { # \\dontrun{ # Same as plm library(plm) mdl <- plm(mpg ~ cyl + disp, mtcars, model = \"pooling\", index = \"clust\") vcov2 <- vcovHC(mdl, type = \"sss\", cluster = \"group\") vcov - vcov2 } # }"},{"path":"https://marberts.github.io/rsmatrix/reference/rsmatrix-package.html","id":null,"dir":"Reference","previous_headings":"","what":"rsmatrix: Matrices for Repeat-Sales Price Indexes — rsmatrix-package","title":"rsmatrix: Matrices for Repeat-Sales Price Indexes — rsmatrix-package","text":"Calculate matrices Shiller (1991, doi:10.1016/S1051-1377(05)80028-2 ) serve foundation many repeat-sales price indexes.","code":""},{"path":[]},{"path":"https://marberts.github.io/rsmatrix/reference/rsmatrix-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"rsmatrix: Matrices for Repeat-Sales Price Indexes — rsmatrix-package","text":"Maintainer: Steve Martin marberts@protonmail.com (ORCID) [copyright holder]","code":""},{"path":"https://marberts.github.io/rsmatrix/news/index.html","id":"rsmatrix-029","dir":"Changelog","previous_headings":"","what":"rsmatrix 0.2.9","title":"rsmatrix 0.2.9","text":"CRAN release: 2024-12-14 Updated maintainer email. rs_pairs() gets new argument match_first control products first period match (#1).","code":""},{"path":"https://marberts.github.io/rsmatrix/news/index.html","id":"rsmatrix-028","dir":"Changelog","previous_headings":"","what":"rsmatrix 0.2.8","title":"rsmatrix 0.2.8","text":"CRAN release: 2023-11-19 Added vignette. rs_matrix() twice fast now.","code":""},{"path":"https://marberts.github.io/rsmatrix/news/index.html","id":"rsmatrix-026","dir":"Changelog","previous_headings":"","what":"rsmatrix 0.2.6","title":"rsmatrix 0.2.6","text":"CRAN release: 2023-06-01 Updated work Matrix >= 1.5-0.","code":""},{"path":"https://marberts.github.io/rsmatrix/news/index.html","id":"rsmatrix-023","dir":"Changelog","previous_headings":"","what":"rsmatrix 0.2.3","title":"rsmatrix 0.2.3","text":"CRAN release: 2022-03-15 Making \"Y\" vector rs_matrix() longer gives error length-0 inputs factor non-empty levels. rs_matrix() cleans enclosing environment result.","code":""},{"path":"https://marberts.github.io/rsmatrix/news/index.html","id":"rsmatrix-021","dir":"Changelog","previous_headings":"","what":"rsmatrix 0.2.1","title":"rsmatrix 0.2.1","text":"CRAN release: 2022-02-13 rs_pairs() rs_matrix() now faster, less picky inputs time periods.","code":""},{"path":"https://marberts.github.io/rsmatrix/news/index.html","id":"rsmatrix-020","dir":"Changelog","previous_headings":"","what":"rsmatrix 0.2.0","title":"rsmatrix 0.2.0","text":"CRAN release: 2021-10-08 rs_pairs() reworked much faster general, rs_unpair() removed. changes backwards compatible. Added French translations. Fixed NOTE LazyData CRAN.","code":""}]
